<script>
const slider = document.getElementById('slider');
const indicator = document.getElementById('pageIndicator');
const prevBtn = document.getElementById('prevBtn');
const nextBtn = document.getElementById('nextBtn');

let pages = Array.from(document.querySelectorAll('.page'));
const total = pages.length;
let current = 0;

// clone ends for infinite loop
const firstClone = pages[0].cloneNode(true);
const lastClone = pages[pages.length - 1].cloneNode(true);
slider.appendChild(firstClone);
slider.prepend(lastClone);
pages = Array.from(document.querySelectorAll('.page'));

let isAnimating = false;
let transitionTimer = null;

// initial position
slider.style.transform = `translateX(-100vw)`;
updateIndicator();

function updateIndicator() {
  indicator.textContent = `Page ${current + 1} of ${total}`;
}

function jumpTo(index) {
  slider.style.transition = 'none';
  slider.style.transform = `translateX(-${(index + 1) * 100}vw)`;
}

function setSlide(index) {
  // guard
  if (isAnimating) return;
  isAnimating = true;

  slider.style.transition = 'transform 0.35s ease-out';
  slider.style.transform = `translateX(-${(index + 1) * 100}vw)`;

  // Safety reset if transitionend never fires
  clearTimeout(transitionTimer);
  transitionTimer = setTimeout(() => {
    isAnimating = false;
  }, 600);
}

slider.addEventListener('transitionend', () => {
  slider.style.transition = 'none';
  if (current < 0) {
    current = total - 1;
    jumpTo(current);
  } else if (current >= total) {
    current = 0;
    jumpTo(current);
  }
  updateIndicator();
  isAnimating = false;
  clearTimeout(transitionTimer);
});

/* -------- Touch swipe handling with improved snapping -------- */
let startX = 0, currentX = 0, startTime = 0, isDragging = false;

slider.addEventListener('touchstart', e => {
  // Cancel any ongoing transition instantly
  clearTimeout(transitionTimer);
  isAnimating = false;
  slider.style.transition = 'none';

  startX = currentX = e.touches[0].clientX;
  startTime = Date.now();
  isDragging = true;
});

slider.addEventListener('touchmove', e => {
  if (!isDragging) return;
  currentX = e.touches[0].clientX;
  const delta = currentX - startX;
  slider.style.transform = `translateX(${delta - (current + 1) * 100}vw)`;
});

slider.addEventListener('touchend', () => {
  if (!isDragging) return;
  isDragging = false;

  const delta = currentX - startX;
  const elapsed = Date.now() - startTime;
  const velocity = Math.abs(delta) / elapsed;

  const screenWidth = window.innerWidth;
  const halfway = screenWidth / 2;

  let moved = false;

  // 1️⃣ If halfway past next page → snap forward/back
  if (Math.abs(delta) > halfway) {
    moved = true;
    current += delta < 0 ? 1 : -1;
  }
  // 2️⃣ If flick is fast enough → move even if short distance
  else if (velocity > 0.5) {
    moved = true;
    current += delta < 0 ? 1 : -1;
  }

  // Otherwise snap back to current
  if (!moved) {
    setSlide(current);
  } else {
    setSlide(current);
  }
});

/* -------- Desktop buttons -------- */
prevBtn.onclick = () => {
  if (isAnimating) return;
  current--;
  setSlide(current);
};
nextBtn.onclick = () => {
  if (isAnimating) return;
  current++;
  setSlide(current);
};

document.addEventListener('keydown', e => {
  if (e.key === 'ArrowLeft' && !isAnimating) {
    current--;
    setSlide(current);
  }
  if (e.key === 'ArrowRight' && !isAnimating) {
    current++;
    setSlide(current);
  }
});
</script>
